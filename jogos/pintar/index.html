<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo de Pintura - Musi Kids</title>
<style>
  /* Estilos gerais */
  @import url('https://fonts.googleapis.com/css2?family=Baloo&display=swap');
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: linear-gradient(135deg, #f9ecd3 0%, #f4a261 100%);
    font-family: 'Baloo', cursive, Arial, sans-serif;
    user-select: none;
    overflow: hidden;
    display: flex; flex-direction: column;
  }
  header {
    font-size: 2rem; font-weight: 900;
    text-align: center; padding: 10px 0;
    background: #e2a343; color: #5B4215; user-select: none;
  }
  #btn-back {
    position: fixed; top: 10px; left: 10px;
    background: #3B7994; color: white;
    border: none; border-radius: 20px;
    padding: 12px 20px;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 6px 15px rgba(0,0,0,0.4);
    z-index: 1000; user-select: none;
    transition: background-color 0.3s ease;
  }
  #btn-back:hover { background: #305f71; }

  /* Top bar somente com undo e redo */
  #top-bar {
    position: fixed; top: 10px; left: 70px; right: 10px;
    height: 50px;
    background: rgba(59, 121, 148, 0.9);
    border-radius: 25px;
    display: flex; align-items: center; justify-content: center;
    gap: 12px;
    padding: 0 15px;
    z-index: 999;
    font-weight: 700;
    color: white;
    font-size: 18px;
  }
  #top-bar button {
    background: #4ea6c1;
    border: none; border-radius: 20px;
    padding: 6px 16px;
    color: white;
    cursor: pointer;
    user-select: none;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    transition: background-color 0.3s ease;
  }
  #top-bar button:disabled {
    background: #97bccd;
    cursor: not-allowed;
  }
  #top-bar button:not(:disabled):hover {
    background: #357d9b;
  }

  /* Ferramentas laterais externas */
  #toolbar {
    position: fixed; top: 70px; left: 10px; width: 64px;
    background: rgba(59, 121, 148, 0.9);
    border-radius: 25px; padding: 10px 6px;
    display: flex; flex-direction: column; gap: 15px;
    align-items: center;
    z-index: 998; user-select: none;
  }
  .tool-btn {
    width: 48px; height: 48px; border-radius: 20px;
    border: none; background: #def3f3; color: #185359;
    font-size: 26px; cursor: pointer;
    display: flex; justify-content: center; align-items: center;
    box-shadow: 0 5px 12px rgba(24, 83, 62, 0.3);
    transition: background-color 0.3s ease;
  }
  .tool-btn.selected {
    background: #185359; color: white;
  }
  .tool-btn:hover {
    background: #a2c1c1; color: #173e3f;
  }
  #color-picker {
    margin-top: 10px;
    width: 44px; height: 44px;
    border-radius: 22px;
    border: none;
    cursor: pointer;
  }
  /* Escala para formas geom√©tricas */
  #scale-controls {
    margin-top: 10px;
    display: flex;
    gap: 6px;
  }
  .scale-btn {
    width: 28px; height: 28px;
    background: #185359;
    color: white; border-radius: 6px;
    border: none;
    cursor: pointer;
    font-weight: 800;
    user-select: none;
  }
  .scale-btn:active {
    background: #0f3c3a;
  }

  /* Paletas direita de imagens e formas */
  #palette-container {
    position: fixed; top: 140px; right: 10px;
    width: 210px; max-height: 60vh;
    background: #fdeed6cc;
    border-radius: 20px;
    box-shadow: 0 5px 18px rgba(168, 84, 14, 0.7);
    padding: 10px;
    overflow-y: auto;
    z-index: 997;
  }
  #palette-container h3 {
    color: #B45105;
    font-weight: 700;
    margin: 0 0 12px 0;
    text-align: center;
    user-select: none;
  }
  .palette-item, .palette-shape {
    width: 90%;
    margin: 6px auto;
    cursor: grab;
    border-radius: 14px;
    box-shadow: 0 4px 11px rgba(168, 84, 14, 0.6);
    user-select: none;
    display: block;
  }
  .palette-shape {
    height: 75px;
    background: white;
    border: 2px solid black;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .palette-shape.circle {
    border-radius: 100%;
  }
  .palette-shape.triangle {
    width: 0;
    height: 0;
    border-left: 38px solid transparent;
    border-right: 38px solid transparent;
    border-bottom: 68px solid black;
    margin-top: 8px;
    margin-bottom: 8px;
  }
  /* Pintura */
  #paint-area-container {
    margin-left: 80px;
    margin-top: 80px;
    flex-grow: 1;
    overflow: auto;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  svg#paint-area {
    border-radius: 20px;
    border: 4px solid #185359;
    background: white;
    max-width: 90vw;
    max-height: 85vh;
    display: block;
    user-select: none;
  }
  path.outline {
    fill: none;
    stroke: black;
    stroke-width: 3;
    pointer-events: none;
  }
  path.fillable {
    fill: white;
    stroke: black;
    stroke-width: 2;
    cursor: pointer;
  }
</style>
</head>
<body>
  <button id="btn-back" aria-label="Menu de jogos" title="Voltar para Menu de Jogos">MENU DE JOGOS</button>

  <div id="top-bar" role="region" aria-label="Controles da pintura" style="justify-content: center;">
    <button id="undo-btn" disabled aria-label="Desfazer">‚Ü©Ô∏è Desfazer</button>
    <button id="redo-btn" disabled aria-label="Refazer">‚Ü™Ô∏è Refazer</button>
  </div>

  <div id="toolbar" role="toolbar" aria-label="Ferramentas">
    <button class="tool-btn selected" id="tool-pencil" aria-pressed="true" aria-label="Selecionar l√°pis">‚úèÔ∏è</button>
    <button class="tool-btn" id="tool-eraser" aria-pressed="false" aria-label="Selecionar borracha">ü©π</button>
    <button class="tool-btn" id="tool-brush" aria-pressed="false" aria-label="Selecionar pincel">üñåÔ∏è</button>
    <div id="scale-controls">
      <button class="scale-btn" id="scale-increase" aria-label="Aumentar tamanho">Ôºã</button>
      <button class="scale-btn" id="scale-decrease" aria-label="Diminuir tamanho">‚àí</button>
    </div>
    <input type="color" id="color-picker" aria-label="Escolher cor" value="#000000" />
  </div>

  <div id="palette-container" aria-label="Paletas de imagens e formas">
    <h3>Imagens para pintar</h3>
    <img src="https://cdn.pixabay.com/photo/2016/10/18/21/06/dinosaur-1784536_1280.jpg" class="palette-item" draggable="true" alt="Dinossauro" />
    <img src="https://cdn.pixabay.com/photo/2014/04/10/10/02/owl-319913_1280.jpg" class="palette-item" draggable="true" alt="Coruja" />
    <img src="https://cdn.pixabay.com/photo/2016/01/22/15/36/dog-1151516_1280.jpg" class="palette-item" draggable="true" alt="Cachorro" />
    <img src="https://cdn.pixabay.com/photo/2016/03/27/19/17/turtle-1280223_1280.jpg" class="palette-item" draggable="true" alt="Tartaruga" />
    <img src="https://cdn.pixabay.com/photo/2017/06/20/09/23/girl-2421493_1280.jpg" class="palette-item" draggable="true" alt="Garota" />
    <h3 style="margin-top: 20px;">Formas Geom√©tricas</h3>
    <div class="palette-shape circle" draggable="true" role="img" aria-label="C√≠rculo" tabindex="0"></div>
    <div class="palette-shape square" draggable="true" role="img" aria-label="Quadrado" tabindex="0"></div>
    <div class="palette-shape triangle" draggable="true" role="img" aria-label="Tri√¢ngulo" tabindex="0"></div>
  </div>

  <div id="paint-area-container">
    <svg id="paint-area" viewBox="0 0 600 400" role="img" aria-label="√Årea para pintar" tabindex="0"  width="100%" height="100%">
      <path class="outline" d="M100 120 Q 160 50, 220 120 T 340 120" />
      <path class="outline" d="M400 180 Q 460 130, 520 180 T 580 190" />
      <path class="fillable" d="M90 110 L350 110 L350 130 L90 130 Z" />
      <path class="fillable" d="M390 170 L590 170 L590 200 L390 200" />
    </svg>
  </div>

  <script>
    const paintArea = document.getElementById("paint-area");
    const svgNS = "http://www.w3.org/2000/svg";

    const btnBack = document.getElementById("btn-back");
    const tools = {
      pencil: document.getElementById("tool-pencil"),
      eraser: document.getElementById("tool-eraser"),
      brush: document.getElementById("tool-brush"),
    };
    const scaleIncrease = document.getElementById("scale-increase");
    const scaleDecrease = document.getElementById("scale-decrease");

    const colorPicker = document.getElementById("color-picker");
    const undoBtn = document.getElementById("undo-btn");
    const redoBtn = document.getElementById("redo-btn");
    const clearBtn = document.getElementById("clear-btn");

    let currentTool = "pencil";
    let currentColor = colorPicker.value;
    let isDrawing = false;
    let currentPath = null;
    let pathData = "";
    let drawingTarget = null;

    let selectedElement = null;
    let scale = 1;

    // Undo/redo stacks
    let undoStack = [];
    let redoStack = [];

    // Functions to update undo/redo button state
    function updateUndoRedoButtons() {
      undoBtn.disabled = undoStack.length === 0;
      redoBtn.disabled = redoStack.length === 0;
    }

    // Push an action to the undo stack
    function pushUndo(action) {
      undoStack.push(action);
      if (undoStack.length > 50) undoStack.shift();
      // Clear redo stack since new action
      redoStack = [];
      updateUndoRedoButtons();
    }

    // Undo the last action
    undoBtn.addEventListener("click", () => {
      if (undoStack.length === 0) return;
      const action = undoStack.pop();
      if (["draw", "erase", "image", "shape"].includes(action.type)) {
        paintArea.removeChild(action.element);
        redoStack.push(action);
      } else if (action.type === "fill") {
        action.element.setAttribute("fill", action.oldColor);
        action.element.setAttribute("data-filled", action.oldFilled);
        redoStack.push(action);
      } else if (action.type === "clear") {
        action.elements.forEach((el) => paintArea.appendChild(el));
        redoStack.push(action);
      }
      updateUndoRedoButtons();
    });

    // Redo the last undone action
    redoBtn.addEventListener("click", () => {
      if (redoStack.length === 0) return;
      const action = redoStack.pop();
      if (["draw", "erase", "image", "shape"].includes(action.type)) {
        paintArea.appendChild(action.element);
        undoStack.push(action);
      } else if (action.type === "fill") {
        action.element.setAttribute("fill", action.newColor);
        action.element.setAttribute("data-filled", "true");
        undoStack.push(action);
      } else if (action.type === "clear") {
        action.elements.forEach((el) => paintArea.removeChild(el));
        undoStack.push(action);
      }
      updateUndoRedoButtons();
    });

    btnBack.onclick = () => {
      location.href = "../";
    };

    // Tool selection
    function selectTool(tool) {
      currentTool = tool;
      for (const key in tools) {
        if (tools[key]) {
          tools[key].classList.toggle("selected", key === tool);
          tools[key].setAttribute("aria-pressed", key === tool ? "true" : "false");
        }
      }
    }
    for (const key in tools) {
      if (tools[key]) {
        tools[key].addEventListener("click", () => {
          selectTool(key);
        });
      }
    }
    selectTool("pencil");

    colorPicker.addEventListener("input", (e) => {
      currentColor = e.target.value;
      // Update selected shape or other elements color if dragging? Optional
    });

    // Drawing handlers
    paintArea.addEventListener("mousedown", (e) => {
      if (currentTool === "bucket") return;
      if (e.target.classList.contains("palette-item") || e.target.classList.contains("palette-shape") || e.target.tagName === "image")
        return;
      isDrawing = true;
      const pt = getSVGPoint(e);
      pathData = `M ${pt.x} ${pt.y}`;
      currentPath = document.createElementNS(svgNS, "path");
      currentPath.setAttribute("fill", "none");
      currentPath.setAttribute("stroke", currentTool === "eraser" ? "#fff" : currentColor);
      currentPath.setAttribute("stroke-width", currentTool === "brush" ? 8 : currentTool === "eraser" ? 12 : 2);
      currentPath.setAttribute("stroke-linejoin", "round");
      currentPath.setAttribute("stroke-linecap", "round");
      currentPath.setAttribute("d", pathData);
      paintArea.appendChild(currentPath);
      pushUndo({ type: currentTool === "eraser" ? "erase" : "draw", element: currentPath });
    });

    paintArea.addEventListener("mousemove", (e) => {
      if (!isDrawing || !currentPath) return;
      const pt = getSVGPoint(e);
      pathData += ` L ${pt.x} ${pt.y}`;
      currentPath.setAttribute("d", pathData);
    });

    paintArea.addEventListener("mouseup", () => {
      isDrawing = false;
      currentPath = null;
    });
    paintArea.addEventListener("mouseleave", () => {
      isDrawing = false;
      currentPath = null;
    });

    // Bucket fill
    paintArea.querySelectorAll("path.fillable").forEach((path) => {
      path.addEventListener("click", (e) => {
        if (currentTool !== "bucket") return;
        const element = e.target;
        const oldColor = element.getAttribute("fill") || "white";
        const oldFilled = element.getAttribute("data-filled") || "false";

        if (oldColor.toLowerCase() === currentColor.toLowerCase() && oldFilled === "true")
          return;

        element.setAttribute("fill", currentColor);
        element.setAttribute("data-filled", "true");
        pushUndo({ type: "fill", element: element, oldColor: oldColor, newColor: currentColor, oldFilled: oldFilled });
      });
    });

    // Drag and drop from palette
    const paletteItems = document.querySelectorAll(".palette-item, .palette-shape");
    paletteItems.forEach((item) => {
      item.setAttribute("draggable", "true");
      item.addEventListener("dragstart", (e) => {
        e.dataTransfer.setData(
          "application/json",
          JSON.stringify({
            type: item.classList.contains("palette-item") ? "image" : "shape",
            src: item.src || null,
            shape: [...item.classList].find((c) => ["circle", "square", "triangle"].includes(c)) || null,
          })
        );
        item.classList.add("dragging");
      });
      item.addEventListener("dragend", () => {
        item.classList.remove("dragging");
      });
    });

    paintArea.addEventListener("dragover", (e) => e.preventDefault());
    paintArea.addEventListener("drop", (e) => {
      e.preventDefault();
      let data = e.dataTransfer.getData("application/json");
      if (!data) return;
      data = JSON.parse(data);

      const pt = getSVGPoint(e);

      if (data.type === "image" && data.src) {
        const img = document.createElementNS(svgNS, "image");
        img.setAttribute("href", data.src);
        img.setAttribute("x", pt.x - 50);
        img.setAttribute("y", pt.y - 50);
        img.setAttribute("width", 100);
        img.setAttribute("height", 100);
        img.style.cursor = "grab";
        paintArea.appendChild(img);
        pushUndo({ type: "image", element: img });
        makeDraggable(img);
      } else if (data.type === "shape" && data.shape) {
        let el;
        if (data.shape === "circle") {
          el = document.createElementNS(svgNS, "circle");
          el.setAttribute("cx", pt.x);
          el.setAttribute("cy", pt.y);
          el.setAttribute("r", 50);
          el.setAttribute("fill", "none");
          el.setAttribute("stroke", "black");
          el.setAttribute("stroke-width", 3);
        } else if (data.shape === "square") {
          el = document.createElementNS(svgNS, "rect");
          el.setAttribute("x", pt.x - 50);
          el.setAttribute("y", pt.y - 50);
          el.setAttribute("width", 100);
          el.setAttribute("height", 100);
          el.setAttribute("fill", "none");
          el.setAttribute("stroke", "black");
          el.setAttribute("stroke-width", 3);
          el.setAttribute("rx", 15);
          el.setAttribute("ry", 15);
        } else if (data.shape === "triangle") {
          el = document.createElementNS(svgNS, "polygon");
          el.setAttribute(
            "points",
            `${pt.x},${pt.y - 58} ${pt.x - 50},${pt.y + 42} ${pt.x + 50},${pt.y + 42}`
          );
          el.setAttribute("fill", "none");
          el.setAttribute("stroke", "black");
          el.setAttribute("stroke-width", 3);
        }
        if (el) {
          el.style.cursor = "grab";
          paintArea.appendChild(el);
          pushUndo({ type: "image", element: el });
          makeDraggable(el);
        }
      }
    });

    function makeDraggable(el) {
      let dragging = false;
      let offsetX, offsetY;

      function getEventPoint(evt) {
        const pt = paintArea.createSVGPoint();
        pt.x = evt.clientX;
        pt.y = evt.clientY;
        return pt.matrixTransform(paintArea.getScreenCTM().inverse());
      }

      el.addEventListener("mousedown", (e) => {
        e.preventDefault();
        isDrawing = false;
        dragging = true;
        let pt = getEventPoint(e);
        if (el.tagName === "circle") {
          offsetX = pt.x - parseFloat(el.getAttribute("cx"));
          offsetY = pt.y - parseFloat(el.getAttribute("cy"));
        } else {
          offsetX = pt.x - parseFloat(el.getAttribute("x"));
          offsetY = pt.y - parseFloat(el.getAttribute("y"));
        }
        el.style.cursor = "grabbing";
      });

      paintArea.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        e.preventDefault();
        let pt = getEventPoint(e);
        if (el.tagName === "circle") {
          el.setAttribute("cx", pt.x - offsetX);
          el.setAttribute("cy", pt.y - offsetY);
        } else {
          el.setAttribute("x", pt.x - offsetX);
          el.setAttribute("y", pt.y - offsetY);
        }
      });

      paintArea.addEventListener("mouseup", () => {
        if (dragging) {
          dragging = false;
          el.style.cursor = "grab";
        }
      });

      paintArea.addEventListener("mouseleave", () => {
        if (dragging) {
          dragging = false;
          el.style.cursor = "grab";
        }
      });
    }
  </script>
</body>
</html>
