<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quebra-Cabe√ßa - MusiKids Fun</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Baloo+2&display=swap');
  
  body {
    margin: 0;
    padding: 1.5rem;
    background: linear-gradient(135deg, #a0eaff 0%, #ffbad2 100%);
    font-family: 'Baloo 2', cursive, Arial, sans-serif;
    color: #333;
    min-height: 100vh;
    user-select: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
  }
  
  /* Bot√£o de Voltar ao Menu - NOVO ESTILO (movido para cima) */
  #voltar-menu-btn {
    position: absolute;
    top: 1.5rem;
    left: 1.5rem;
    padding: 0.5rem 1rem; /* Menor que o bot√£o de iniciar */
    font-size: 1rem;
    border-radius: 12px;
    box-shadow: 0 4px 10px #ffadc3b0;
    z-index: 10; /* Garante que fique por cima */
  }

  header {
    font-weight: 900;
    font-size: 2.1rem;
    margin-bottom: 1.5rem;
    color: #ff4c8b;
    text-shadow: 0 2px 8px #ffe1ee;
  }
  
  #config {
    width: 320px;
    background: #fff1f9;
    border-radius: 18px;
    padding: 1.3rem 1.6rem;
    box-shadow: 0 6px 30px #ffcce1a0;
    margin-bottom: 2rem;
  }
  
  label {
    font-weight: 700;
    display: block;
    margin-bottom: 0.5rem;
    color: #d23065;
    user-select: none;
  }
  
  select {
    width: 100%;
    padding: 0.4rem 0.6rem;
    font-size: 1rem;
    border-radius: 12px;
    border: 2px solid #ff2d7f;
    background: white;
    cursor: pointer;
    user-select: none;
    margin-bottom: 12px;
  }
  
  /* Alterado para 'display: block' pois s√≥ tem 1 bot√£o agora */
  #btns-row {
    display: block;
  }
  
  /* Estilo base para os bot√µes */
  button, a.btn {
    /* 'flex: 1' removido daqui para permitir o posicionamento do bot√£o de voltar */
    padding: 1rem 0;
    font-weight: 700;
    border-radius: 20px;
    border: none;
    background-color: #ff4c8b;
    color: white;
    font-size: 1.25rem;
    cursor: pointer;
    box-shadow: 0 10px 20px #ffadc3b0;
    transition: background-color 0.3s ease, transform 0.25s ease;
    text-decoration: none;
    display: inline-block;
    user-select: none;
  }
  
  /* Estilo espec√≠fico para o bot√£o Iniciar (para ocupar a largura) */
  button#start-btn {
    width: 100%;
    margin-top: 1rem; /* Adiciona espa√ßo acima do bot√£o */
  }

  button:hover, a.btn:hover {
    background-color: #e93c73;
    transform: scale(1.04);
  }
  
  #puzzle-container {
    display: none;
    margin-bottom: 2rem;
    width: 90vw;
    max-width: 500px;
    background: #fff0f7;
    border-radius: 20px;
    box-shadow: 0 8px 38px #ffa4c5cc;
    user-select: none;
  }
  
  #puzzle {
    display: grid;
    gap: 2px;
    margin: auto;
    background: #ffbad2cc;
    border-radius: 20px;
    overflow: hidden;
    user-select: none;
  }
  
  .piece {
    cursor: grab;
    user-select: none;
    border-radius: 10px;
    box-shadow: 0 8px 19px #ff70a0aa;
    transition: box-shadow 0.25s;
    background-repeat: no-repeat;
    background-size: 100% 100%;
  }
  
  .piece.dragging {
    cursor: grabbing;
    box-shadow: 0 14px 28px #ff377bee;
  }
  
  #instructions {
    font-weight: 700;
    margin: 0.8rem 0 12px 0;
    color: #d23065;
    user-select: none;
    min-height: 2.3em;
  }
  
  @media (max-width: 600px) {
    .piece {
      border-radius: 8px;
      box-shadow: 0 5px 15px #ff70a0cc;
    }
    #config { width: 98vw; }
    #puzzle-container { width: 99vw; max-width: 99vw; }
    
    /* Ajusta o bot√£o de voltar em telas pequenas */
    #voltar-menu-btn {
        top: 1rem;
        left: 1rem;
        padding: 0.4rem 0.8rem;
        font-size: 0.9rem;
    }
    
    header {
        margin-top: 2.5rem; /* Adiciona espa√ßo para n√£o sobrepor o bot√£o */
    }
  }
</style>
</head>
<body>

<a href="../index.html" role="button" class="btn" id="voltar-menu-btn" aria-label="Voltar ao Menu de Jogos">‚Üê Menu</a>

<header>Quebra-Cabe√ßa - MusiKids Fun</header>

<div id="config" aria-label="Configura√ß√µes do quebra-cabe√ßa">

  <label for="pieces-select">N√≠vel (pe√ßas):</label>
  <select id="pieces-select" aria-describedby="pieces-desc" aria-required="true">
    <option value="4" selected>Muito F√°cil (2x2)</option>
    <option value="6">F√°cil (3x2)</option>
    <option value="9">M√©dio (3x3)</option>
    <option value="15">Dif√≠cil (5x3)</option>
  </select>

  <label for="image-select">Selecione a imagem:</label>
  <select id="image-select" aria-describedby="image-desc" aria-required="true">
    <option value="https://cdn.pixabay.com/photo/2020/03/24/08/33/lion-4962779_1280.png" selected>Le√£ozinho ü¶Å</option>
    <option value="https://cdn.pixabay.com/photo/2016/09/16/10/16/teddy-bear-1673550_1280.png">Ursinho üß∏</option>
    <option value="https://cdn.pixabay.com/photo/2013/07/12/17/45/rubber-duck-152335_1280.png">Patinho ü¶Ü</option>
    <option value="https://cdn.pixabay.com/photo/2017/01/31/23/52/bunny-2027986_1280.png">Coelhinho üê∞</option>
    <option value="https://cdn.pixabay.com/photo/2016/04/01/10/48/animal-1299942_1280.png">Macaquinho üêµ</option>
    <option value="https://cdn.pixabay.com/photo/2013/07/13/13/27/fish-161099_1280.png">Peixinho üê†</option>
    <option value="https://cdn.pixabay.com/photo/2020/05/11/15/38/cat-5158888_1280.png">Gatinho üê±</option>
    <option value="https://cdn.pixabay.com/photo/2016/03/31/20/35/dog-1295794_1280.png">Cachorrinho üê∂</option>
  </select>

  <div id="btns-row">
    <button id="start-btn" aria-label="Iniciar Quebra-Cabe√ßa">Iniciar Quebra-Cabe√ßa</button>
    </div>
</div>

<p id="instructions" aria-live="polite"></p>

<div id="puzzle-container" role="main" aria-label="√Årea do Quebra-Cabe√ßa" tabindex="0" aria-live="polite" aria-atomic="true" style="display:none;">
  <div id="puzzle"></div>
</div>

<div id="confetti"></div>

<script>
  const puzzle = document.getElementById("puzzle");
  const piecesSelect = document.getElementById("pieces-select");
  const imageSelect = document.getElementById("image-select");
  const startBtn = document.getElementById("start-btn");
  const instructions = document.getElementById("instructions");
  const puzzleContainer = document.getElementById("puzzle-container");

  let rows, cols, totalPieces;
  let pieces = [];
  let originalPositions = [];
  let imageUrl;

  // FUN√á√ÉO ATUALIZADA para incluir os novos n√≠veis
  function determineGrid(total) {
    if(total === 4){ rows = 2; cols = 2; }
    else if(total === 6){ rows = 2; cols = 3; }
    else if(total === 9){ rows = 3; cols = 3; }
    else if(total === 15){ rows = 3; cols = 5;}
    else if(total === 20){ rows = 4; cols = 5;} // Mantido por seguran√ßa
    else { rows = 2; cols = 2;} // Padr√£o √© o mais f√°cil
  }

  function shuffle(array){
    for(let i = array.length - 1; i > 0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  startBtn.onclick = () => {
    totalPieces = Number(piecesSelect.value);
    determineGrid(totalPieces);
    imageUrl = imageSelect.value;
    instructions.textContent = "Carregando imagem...";
    const img = new Image();
    img.onload = () => {
      puzzleContainer.style.display = 'block';
      instructions.textContent = `Monte o quebra-cabe√ßa de ${totalPieces} pe√ßas!`;
      createPuzzle();
    };
    img.onerror = () => {
      instructions.textContent = "Erro ao carregar a imagem, tente outra.";
      puzzleContainer.style.display = 'none';
      console.error("Erro ao carregar imagem: " + imageUrl);
    };
    img.src = imageUrl;
  };

  function createPuzzle() {
    puzzle.innerHTML = "";
    puzzle.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    puzzle.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
    pieces = [];
    originalPositions = [];

    for(let r=0; r<rows; r++){
      for(let c=0; c<cols; c++){
        const idx = r*cols + c;
        if(idx >= totalPieces) break;

        const piece = document.createElement("div");
        piece.classList.add("piece");
        piece.style.backgroundImage = `url(${imageUrl})`;
        piece.style.backgroundSize = `${cols*100}% ${rows*100}%`;
        
        // Ajuste no c√°lculo da posi√ß√£o para funcionar com 2 ou mais colunas/linhas
        const xPos = (cols > 1) ? (c * 100) / (cols - 1) : 0;
        const yPos = (rows > 1) ? (r * 100) / (rows - 1) : 0;
        piece.style.backgroundPosition = `${xPos}% ${yPos}%`;
        
        piece.draggable = true;
        piece.dataset.index = idx;

        puzzle.appendChild(piece);
        pieces.push(piece);
        originalPositions.push(idx);
      }
    }

    shufflePieces();
  }

  function shufflePieces() {
    shuffle(originalPositions);
    originalPositions.forEach(i => puzzle.appendChild(pieces[i]));
    addListeners();
  }

  function addListeners() {
    Array.from(puzzle.children).forEach(piece => {
      piece.addEventListener("dragstart", dragStart);
      piece.addEventListener("dragover", dragOver);
      piece.addEventListener("drop", drop);
      piece.addEventListener("dragenter", dragEnter);
      piece.addEventListener("dragleave", dragLeave);
      piece.addEventListener("dragend", dragEnd);
      
      // Listeners para Touch (celular)
      piece.addEventListener("touchstart", dragStart, { passive: false });
      piece.addEventListener("touchmove", dragOver, { passive: false });
      piece.addEventListener("touchend", drop, { passive: false });
    });
  }

  let draggedPiece = null;
  let touchIdentifier = null; // Para mobile

  function getTouch(e) {
      if (e.changedTouches) {
          return e.changedTouches[0];
      }
      return e;
  }

  function dragStart(e){
    // Previne comportamento padr√£o (como scroll)
    if (e.type === 'touchstart') {
        if(e.touches.length > 1) return; // Ignora multi-touch
        e.preventDefault();
        touchIdentifier = e.changedTouches[0].identifier;
    }
    
    draggedPiece = e.target;
    
    if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "move";
    }
    
    // Usamos setTimeout para o 'dragging' funcionar bem no mobile
    setTimeout(() => {
        if (draggedPiece) draggedPiece.classList.add("dragging");
    }, 0);
  }
  
  function dragOver(e){
    e.preventDefault(); // Necess√°rio para o 'drop' funcionar
    
    if (e.dataTransfer) {
        e.dataTransfer.dropEffect = "move";
    }
    
    let target = getTargetFromTouch(e);
    if(target && target !== draggedPiece && target.classList.contains('piece')) {
        // Remove 'drag-over' de outros elementos
        Array.from(puzzle.children).forEach(p => p.classList.remove("drag-over"));
        target.classList.add("drag-over");
    }
  }

  function getTargetFromTouch(e) {
      if (e.type === 'touchmove' || e.type === 'touchend') {
          if (touchIdentifier === null) return null;
          let touch = Array.from(e.changedTouches).find(t => t.identifier === touchIdentifier);
          if (!touch) return null;
          
          // Encontra o elemento sob o toque
          return document.elementFromPoint(touch.clientX, touch.clientY);
      }
      // Para mouse events
      return e.target;
  }
  
  function dragEnter(e){
    let target = e.target;
    if(target && target !== draggedPiece && target.classList.contains('piece')) {
        target.classList.add("drag-over");
    }
  }
  
  function dragLeave(e){
    let target = e.target;
    if(target && target.classList.contains('piece')) {
        target.classList.remove("drag-over");
    }
  }
  
  function drop(e){
    e.preventDefault();
    let target = getTargetFromTouch(e);
    
    if(target && target !== draggedPiece && target.classList.contains('piece')) {
        swapPieces(draggedPiece, target);
        target.classList.remove("drag-over");
    }
    
    // Limpa o 'draggedPiece' no final do drag (dragEnd)
    // Se for touch, limpamos aqui e tamb√©m chamamos dragEnd
    if (e.type === 'touchend') {
        dragEnd();
    }
  }
  
  function dragEnd(){
    if(draggedPiece) {
        draggedPiece.classList.remove("dragging");
    }
    Array.from(puzzle.children).forEach(p => p.classList.remove("drag-over"));
    
    // Reseta o estado
    draggedPiece = null;
    touchIdentifier = null;
    
    checkComplete();
  }
  
  function swapPieces(p1, p2){
    if (!p1 || !p2) return; // Checagem de seguran√ßa
    
    let parent = p1.parentNode;
    let idx1 = Array.from(parent.children).indexOf(p1);
    let idx2 = Array.from(parent.children).indexOf(p2);

    // L√≥gica de troca mais robusta
    if (idx1 < idx2) {
        parent.insertBefore(p2, p1); // Move p2 antes de p1
        parent.insertBefore(p1, parent.children[idx2]); // Move p1 para a posi√ß√£o original de p2
    } else {
        parent.insertBefore(p1, p2); // Move p1 antes de p2
        parent.insertBefore(p2, parent.children[idx1]); // Move p2 para a posi√ß√£o original de p1
    }
  }
  
  function checkComplete(){
    let order = Array.from(puzzle.children).map(p => Number(p.dataset.index));
    if(order.every((val,i) => val === i)){
      instructions.textContent = "Parab√©ns! Voc√™ completou o quebra-cabe√ßa!";
      // Adicionar algum efeito de confete ou celebra√ß√£o aqui seria legal
    }
    else{
      instructions.textContent = `Monte o quebra-cabe√ßa de ${totalPieces} pe√ßas!`;
    }
  }
</script>
</body>
</html>
