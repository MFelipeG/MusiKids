<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quebra-Cabe√ßa - MusiKids Fun</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Baloo+2&display=swap');
 
  body {
    margin: 0;
    padding: 1.5rem;
    background: linear-gradient(135deg, #a0eaff 0%, #ffbad2 100%);
    font-family: 'Baloo 2', cursive, Arial, sans-serif;
    color: #333;
    min-height: 100vh;
    user-select: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    position: relative;
    overflow-x: hidden;
  }
 
  /* Bot√£o de Voltar ao Menu - NOVO ESTILO (movido para cima) */
  #voltar-menu-btn {
    position: absolute;
    top: 1.5rem;
    left: 1.5rem;
    padding: 0.5rem 1rem; /* Menor que o bot√£o de iniciar */
    font-size: 1rem;
    border-radius: 12px;
    box-shadow: 0 4px 10px #ffadc3b0;
    z-index: 10; /* Garante que fique por cima */
  }
  header {
    font-weight: 900;
    font-size: 2.1rem;
    margin-bottom: 1.5rem;
    color: #ff4c8b;
    text-shadow: 0 2px 8px #ffe1ee;
  }
 
  #config {
    width: 320px;
    background: #fff1f9;
    border-radius: 18px;
    padding: 1.3rem 1.6rem;
    box-shadow: 0 6px 30px #ffcce1a0;
    margin-bottom: 2rem;
  }
 
  label {
    font-weight: 700;
    display: block;
    margin-bottom: 0.5rem;
    color: #d23065;
    user-select: none;
  }
 
  select {
    width: 100%;
    padding: 0.4rem 0.6rem;
    font-size: 1rem;
    border-radius: 12px;
    border: 2px solid #ff2d7f;
    background: white;
    cursor: pointer;
    user-select: none;
    margin-bottom: 12px;
  }
 
  /* Alterado para 'display: block' pois s√≥ tem 1 bot√£o agora */
  #btns-row {
    display: block;
  }
 
  /* Estilo base para os bot√µes */
  button, a.btn {
    /* 'flex: 1' removido daqui para permitir o posicionamento do bot√£o de voltar */
    padding: 1rem 0;
    font-weight: 700;
    border-radius: 20px;
    border: none;
    background-color: #ff4c8b;
    color: white;
    font-size: 1.25rem;
    cursor: pointer;
    box-shadow: 0 10px 20px #ffadc3b0;
    transition: background-color 0.3s ease, transform 0.25s ease;
    text-decoration: none;
    display: inline-block;
    user-select: none;
  }
 
  /* Estilo espec√≠fico para o bot√£o Iniciar (para ocupar a largura) */
  button#start-btn {
    width: 100%;
    margin-top: 1rem; /* Adiciona espa√ßo acima do bot√£o */
  }
  button:hover, a.btn:hover {
    background-color: #e93c73;
    transform: scale(1.04);
  }
 
  #puzzle-container {
    display: none;
    margin-bottom: 2rem;
    width: 90vw;
    max-width: 500px;
    background: #fff0f7;
    border-radius: 20px;
    box-shadow: 0 8px 38px #ffa4c5cc;
    user-select: none;
    padding: 1rem; /* Adicionado para dar espa√ßo interno */
  }
 
  #puzzle {
    display: grid;
    gap: 2px;
    margin: auto;
    background: #ffbad2cc;
    border-radius: 20px;
    overflow: hidden;
    user-select: none;
    width: 100%;
    height: auto; /* Agora responsivo via aspect-ratio */
    min-height: 200px; /* M√≠nimo para n√£o colapsar */
  }
 
  .piece {
    cursor: grab;
    user-select: none;
    border-radius: 10px;
    box-shadow: 0 8px 19px #ff70a0aa;
    transition: box-shadow 0.25s;
    background-repeat: no-repeat;
    background-size: 100% 100%;
    display: flex; /* Garante que ocupe o espa√ßo da grid */
    align-items: center;
    justify-content: center;
  }
 
  .piece.dragging {
    cursor: grabbing;
    box-shadow: 0 14px 28px #ff377bee;
  }
 
  #instructions {
    font-weight: 700;
    margin: 0.8rem 0 12px 0;
    color: #d23065;
    user-select: none;
    min-height: 2.3em;
  }

  /* Estilos para o confete */
  #confetti {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 100;
    display: none;
  }

  .confetti-piece {
    position: absolute;
    width: 10px;
    height: 10px;
    background-color: #ff4c8b;
    pointer-events: none;
    animation: confetti-fall 3s linear infinite;
  }

  .confetti-piece:nth-child(odd) {
    background-color: #a0eaff;
    animation-duration: 4s;
  }

  .confetti-piece:nth-child(3n) {
    background-color: #ffbad2;
    animation-duration: 2.5s;
  }

  .confetti-piece:nth-child(4n) {
    background-color: #fff1f9;
    animation-duration: 3.5s;
  }

  @keyframes confetti-fall {
    0% {
      transform: translateY(-100vh) rotate(0deg);
      opacity: 1;
    }
    100% {
      transform: translateY(100vh) rotate(720deg);
      opacity: 0;
    }
  }
 
  @media (max-width: 600px) {
    .piece {
      border-radius: 8px;
      box-shadow: 0 5px 15px #ff70a0cc;
    }
    #config { width: 98vw; }
    #puzzle-container { width: 99vw; max-width: 99vw; }
    #puzzle { min-height: 150px; } /* M√≠nimo menor em mobile */
   
    /* Ajusta o bot√£o de voltar em telas pequenas */
    #voltar-menu-btn {
        top: 1rem;
        left: 1rem;
        padding: 0.4rem 0.8rem;
        font-size: 0.9rem;
    }
   
    header {
        margin-top: 2.5rem; /* Adiciona espa√ßo para n√£o sobrepor o bot√£o */
    }
  }

  /* Para telas maiores (desktop), limita a altura m√°xima */
  @media (min-width: 768px) {
    #puzzle { 
      max-height: 400px; 
    }
  }
</style>
</head>
<body>
<a href="../index.html" role="button" class="btn" id="voltar-menu-btn" aria-label="Voltar ao Menu de Jogos">‚Üê Menu</a>
<header>Quebra-Cabe√ßa - MusiKids Fun</header>
<div id="config" aria-label="Configura√ß√µes do quebra-cabe√ßa">
  <label for="pieces-select">N√≠vel (pe√ßas):</label>
  <select id="pieces-select" aria-describedby="pieces-desc" aria-required="true">
    <option value="4" selected>Muito F√°cil (2x2)</option>
    <option value="6">F√°cil (3x2)</option>
    <option value="9">M√©dio (3x3)</option>
    <option value="15">Dif√≠cil (5x3)</option>
  </select>
  <label for="image-select">Selecione a imagem:</label>
  <select id="image-select" aria-describedby="image-desc" aria-required="true">
            <!-- Se√ß√£o Especial MusiKids --> 
            <option value="https://i.imgur.com/koHNUpP.jpeg">Logo MusiKids üéµ</option>
            <option value="https://i.imgur.com/Bsjz43J.jpeg">Meu Amorzinho ‚ù§Ô∏è</option>
            <option value="https://i.imgur.com/l9ovoXM.jpeg">Animais ü¶ÅüêØü¶í</option>
            <option value="https://i.imgur.com/jIqPKoT.jpeg">Passarinho üê¶</option>
            <option value="https://i.imgur.com/KT8ikZ4.jpeg">Gatinho üê±</option>
            <option value="https://i.imgur.com/QECa0xX.jpeg">Girafa ü¶í</option>
            <option value="https://i.imgur.com/7L4usk5.png">M√£e e Filha üë©‚Äçüëß</option>
            <option value="https://i.imgur.com/Hu94nWs.jpeg">Menina e Formiga üëßüêú</option>
            <option value="https://i.imgur.com/bBbs67d.jpeg">O Sapinho üê∏</option>
            </select>
          <div id="btns-row">
                      <button id="start-btn" aria-label="Iniciar Quebra-Cabe√ßa">Iniciar Quebra-Cabe√ßa</button>
                    </div>
  <div id="puzzle"></div>
</div>
<div id="confetti"></div>
<script>
  const puzzle = document.getElementById("puzzle");
  const piecesSelect = document.getElementById("pieces-select");
  const imageSelect = document.getElementById("image-select");
  const startBtn = document.getElementById("start-btn");
  document.addEventListener('DOMContentLoaded', () => {
  const instructions = document.getElementById("instructions");
  const puzzleContainer = document.getElementById("puzzle-container");
  const confettiContainer = document.getElementById("confetti");
  let rows, cols, totalPieces;
  let pieces = [];
  let originalPositions = [];
  let imageUrl;
  let confettiInterval; // Para controlar o confete

  // FUN√á√ÉO ATUALIZADA para incluir os novos n√≠veis
  function determineGrid(total) {
    if(total === 4){ rows = 2; cols = 2; }
    else if(total === 6){ rows = 2; cols = 3; }
    else if(total === 9){ rows = 3; cols = 3; }
    else if(total === 15){ rows = 3; cols = 5;}
    else if(total === 20){ rows = 4; cols = 5;} // Mantido por seguran√ßa
    else { rows = 2; cols = 2;} // Padr√£o √© o mais f√°cil
  }
  function shuffle(array){
    for(let i = array.length - 1; i > 0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  // Fun√ß√£o para criar e animar confetes
  function createConfetti() {
    confettiContainer.style.display = 'block';
    let pieceCount = 0;
    const maxPieces = 100;
    confettiInterval = setInterval(() => {
      if (pieceCount >= maxPieces) {
        clearInterval(confettiInterval);
        setTimeout(() => {
          confettiContainer.innerHTML = '';
          confettiContainer.style.display = 'none';
        }, 3000); // Para os √∫ltimos confetes ca√≠rem
        return;
      }

      const confettiPiece = document.createElement('div');
      confettiPiece.classList.add('confetti-piece');
      confettiPiece.style.left = Math.random() * 100 + 'vw';
      confettiPiece.style.animationDelay = Math.random() * 2 + 's';
      confettiPiece.style.transform = `rotate(${Math.random() * 360}deg)`;
      confettiContainer.appendChild(confettiPiece);
      pieceCount++;

      // Remove ap√≥s anima√ß√£o
      setTimeout(() => {
        if (confettiPiece.parentNode) {
          confettiPiece.parentNode.removeChild(confettiPiece);
        }
      }, 4000);
    }, 50);
  }

  startBtn.onclick = () => {
    totalPieces = Number(piecesSelect.value);
    determineGrid(totalPieces);
    imageUrl = imageSelect.value;
    instructions.textContent = "Carregando imagem...";
   
    const img = new Image();
   
    img.onload = () => {
      puzzleContainer.style.display = 'block';
      instructions.textContent = `Monte o quebra-cabe√ßa de ${totalPieces} pe√ßas!`;
      createPuzzle();
    };
    img.onerror = () => {
      instructions.textContent = "Erro ao carregar a imagem, tente outra.";
      puzzleContainer.style.display = 'none';
      console.error("Erro ao carregar imagem: " + imageUrl);
    };
    img.src = imageUrl;
  };
  function createPuzzle() {
    puzzle.innerHTML = "";
    puzzle.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    puzzle.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
    // Define aspect-ratio baseado no grid para manter propor√ß√£o correta
    puzzle.style.aspectRatio = `${cols} / ${rows}`;
    pieces = [];
    originalPositions = [];
    for(let r=0; r<rows; r++){
      for(let c=0; c<cols; c++){
        const idx = r*cols + c;
        if(idx >= totalPieces) break;
        const piece = document.createElement("div");
        piece.classList.add("piece");
        piece.style.backgroundImage = `url(${imageUrl})`;
        piece.style.backgroundSize = `${cols*100}% ${rows*100}%`;
       
        // Ajuste no c√°lculo da posi√ß√£o para funcionar com 2 ou mais colunas/linhas
        const xPos = (cols > 1) ? (c * 100) / (cols - 1) : 0;
        const yPos = (rows > 1) ? (r * 100) / (rows - 1) : 0;
        piece.style.backgroundPosition = `${xPos}% ${yPos}%`;
       
        piece.draggable = true;
        piece.dataset.index = idx;
        puzzle.appendChild(piece);
        pieces.push(piece);
        originalPositions.push(idx);
      }
    }
    shufflePieces();
  }
  function isSolved() {
    let order = Array.from(puzzle.children).map(p => Number(p.dataset.index));
    return order.every((val, i) => val === i);
  }
  function shufflePieces() {
    let attempts = 0;
    do {
      shuffle(originalPositions);
      // Limpa e re-aplica para reordenar
      while (puzzle.firstChild) {
        puzzle.removeChild(puzzle.firstChild);
      }
      originalPositions.forEach(i => puzzle.appendChild(pieces[i]));
      attempts++;
    } while (isSolved() && attempts < 10); // Evita loop infinito, mas raro
    addListeners();
  }
  function addListeners() {
    Array.from(puzzle.children).forEach(piece => {
      piece.addEventListener("dragstart", dragStart);
      piece.addEventListener("dragover", dragOver);
      piece.addEventListener("drop", drop);
      piece.addEventListener("dragenter", dragEnter);
      piece.addEventListener("dragleave", dragLeave);
      piece.addEventListener("dragend", dragEnd);
     
      // Listeners para Touch (celular)
      piece.addEventListener("touchstart", dragStart, { passive: false });
      piece.addEventListener("touchmove", dragOver, { passive: false });
      piece.addEventListener("touchend", drop, { passive: false });
    });
  }
  let draggedPiece = null;
  let touchIdentifier = null; // Para mobile
  function getTouch(e) {
      if (e.changedTouches) {
          return e.changedTouches[0];
      }
      return e;
  }
  function dragStart(e){
    // Previne comportamento padr√£o (como scroll)
    if (e.type === 'touchstart') {
        if(e.touches.length > 1) return; // Ignora multi-touch
        e.preventDefault();
        touchIdentifier = e.changedTouches[0].identifier;
    }
   
    draggedPiece = e.target;
   
    if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "move";
    }
   
    // Usamos setTimeout para o 'dragging' funcionar bem no mobile
    setTimeout(() => {
        if (draggedPiece) draggedPiece.classList.add("dragging");
    }, 0);
  }
 
  function dragOver(e){
    e.preventDefault(); // Necess√°rio para o 'drop' funcionar
   
    if (e.dataTransfer) {
        e.dataTransfer.dropEffect = "move";
    }
   
    let target = getTargetFromTouch(e);
    if(target && target !== draggedPiece && target.classList.contains('piece')) {
        // Remove 'drag-over' de outros elementos
        Array.from(puzzle.children).forEach(p => p.classList.remove("drag-over"));
        target.classList.add("drag-over");
    }
  }
  function getTargetFromTouch(e) {
      if (e.type === 'touchmove' || e.type === 'touchend') {
          if (touchIdentifier === null) return null;
          let touch = Array.from(e.changedTouches).find(t => t.identifier === touchIdentifier);
          if (!touch) return null;
         
          // Encontra o elemento sob o toque
          return document.elementFromPoint(touch.clientX, touch.clientY);
      }
      // Para mouse events
      return e.target;
  }
 
  function dragEnter(e){
    let target = e.target;
    if(target && target !== draggedPiece && target.classList.contains('piece')) {
        target.classList.add("drag-over");
    }
  }
 
  function dragLeave(e){
    let target = e.target;
    if(target && target.classList.contains('piece')) {
        target.classList.remove("drag-over");
    }
  }
 
  function drop(e){
    e.preventDefault();
    let target = getTargetFromTouch(e);
   
    if(target && target !== draggedPiece && target.classList.contains('piece')) {
        swapPieces(draggedPiece, target);
        target.classList.remove("drag-over");
    }
   
    // Limpa o 'draggedPiece' no final do drag (dragEnd)
    // Se for touch, limpamos aqui e tamb√©m chamamos dragEnd
    if (e.type === 'touchend') {
        dragEnd();
    }
  }
 
  function dragEnd(){
    if(draggedPiece) {
        draggedPiece.classList.remove("dragging");
    }
    Array.from(puzzle.children).forEach(p => p.classList.remove("drag-over"));
   
    // Reseta o estado
    draggedPiece = null;
    touchIdentifier = null;
   
    checkComplete();
  }
 
  // Fun√ß√£o corrigida para trocar pe√ßas de forma confi√°vel (agora funciona em ambas as dire√ß√µes)
  function swapPieces(el1, el2) {
    if (!el1 || !el2 || el1 === el2) return;
    const parent = el1.parentNode;
    if (parent !== el2.parentNode) return;
    
    // M√©todo seguro usando um marcador tempor√°rio
    const marker = document.createElement('div');
    parent.insertBefore(marker, el1);
    parent.insertBefore(el1, el2);
    parent.insertBefore(el2, marker);
    parent.removeChild(marker);
  }
 
  function checkComplete(){
    let order = Array.from(puzzle.children).map(p => Number(p.dataset.index));
    if(order.every((val,i) => val === i)){
      instructions.textContent = "Parab√©ns! Voc√™ completou o quebra-cabe√ßa!";
      createConfetti(); // Ativa o confete!
    }
    else{
      instructions.textContent = `Monte o quebra-cabe√ßa de ${totalPieces} pe√ßas!`;
    }
  }
});
                            </script>

</body>
</html>
