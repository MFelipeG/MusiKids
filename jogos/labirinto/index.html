<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Jogo do Labirinto - MusiKids Fun</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Baloo+2&display=swap');
  body {
    margin: 0; padding: 0;
    font-family: 'Baloo 2', cursive, Arial, sans-serif;
    background: linear-gradient(135deg, #ffefd5, #ffc0cb);
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    min-height: 100vh;
  }
  #btn-menu {
    position: fixed;
    top: 15px;
    left: 15px;
    background: #a1d578;
    color: #214d0d;
    padding: 12px 22px;
    border-radius: 20px;
    font-weight: 900;
    border: none;
    cursor: pointer;
    box-shadow: 0 0 15px #a1d578cc;
    transition: background-color 0.3s ease;
    z-index: 10;
  }
  #btn-menu:hover {
    background-color: #68922b;
    color: white;
  }
  header {
    margin: 80px 0 15px;
    font-weight: 900;
    font-size: 2.8rem;
    color: #d63a6d;
  }
  #maze-container {
    display: grid;
    grid-template-columns: repeat(21, 20px);
    grid-template-rows: repeat(21, 20px);
    gap: 1.5px;
    background-color: #fff0f6;
    padding: 12px;
    border-radius: 20px;
    box-shadow: 0 0 30px #f3bbcfbb;
    touch-action: manipulation;
  }
  .cell {
    width: 20px;
    height: 20px;
    border-radius: 4px;
    box-sizing: border-box;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 16px;
  }
  .wall {
    background-color: #4b2e83;
  }
  .path {
    background-color: #ffc0cb;
  }
  .player {
    font-size: 18px;
    user-select: none;
  }
  #message {
    margin-top: 25px;
    font-weight: 800;
    font-size: 1.3rem;
    color: #d63a6d;
    min-height: 24px;
    user-select: none;
  }
  #control-instruction {
    margin: 26px 0 0 0;
    color: #4b2e83;
    background: #ffecfa;
    border-radius: 14px;
    font-size: 1.15rem;
    padding: 10px;
    font-weight: 700;
    box-shadow: 0 1px 8px #ffd2fa33;
    max-width: 380px;
    display: inline-block;
  }
  #controls {
    margin: 13px 0 0 0;
    display: flex;
    gap: 15px;
    justify-content: center;
    align-items: center;
  }
  button.control-btn {
    background: #ffb6c1;
    border: none;
    padding: 12px 18px;
    border-radius: 14px;
    font-size: 1.1rem;
    font-weight: 700;
    color: #4b2e83;
    cursor: pointer;
    box-shadow: 0 0 15px #ffb6c1cc;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  button.control-btn:active {
    background-color: #d36487;
    color: white;
  }
</style>
</head>
<body>
<button id="btn-menu" aria-label="Voltar ao menu">MENU DE JOGOS</button>
<header>Jogo do Labirinto - MusiKids Fun</header>
<div id="maze-container" aria-label="Labirinto"></div>
<div id="message" aria-live="assertive"></div>
<div id="control-instruction">
  Use as setas do teclado <span style="font-size:1.2em;">‚¨ÜÔ∏è ‚¨áÔ∏è ‚¨ÖÔ∏è ‚û°Ô∏è</span> ou os bot√µes abaixo para jogar!
</div>
<div id="controls" aria-label="Controles do jogo">
  <button class="control-btn" id="btn-up" aria-label="Mover para cima">‚¨ÜÔ∏è</button>
  <button class="control-btn" id="btn-left" aria-label="Mover para esquerda">‚¨ÖÔ∏è</button>
  <button class="control-btn" id="btn-down" aria-label="Mover para baixo">‚¨áÔ∏è</button>
  <button class="control-btn" id="btn-right" aria-label="Mover para direita">‚û°Ô∏è</button>
</div>

<script>
const btnMenu = document.getElementById('btn-menu');
btnMenu.onclick = () => location.href = '../index.html';

const mazeContainer = document.getElementById('maze-container');
const message = document.getElementById('message');
const controls = {
  up: document.getElementById('btn-up'),
  left: document.getElementById('btn-left'),
  down: document.getElementById('btn-down'),
  right: document.getElementById('btn-right')
};

const CELL_WALL = 1;
const CELL_PATH = 0;
const GRID_SIZE = 21;

let mazes = [];
let currentMazeIndex = 0;
let playerPosition = {x: 1, y: 0};
let exitPosition = null;
let solvedTimeout = null;
let gameCompleted = false;

function playErrorSound() {
  if(gameCompleted) return;
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  oscillator.type = 'triangle';
  oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
  gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.2);
}

function generateMaze() {
  const maze = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(CELL_WALL));
  for(let y=1; y<GRID_SIZE; y+=2) {
    for(let x=1; x<GRID_SIZE; x+=2) {
      maze[y][x] = CELL_PATH;
    }
  }

  const stack = [];
  let cx = 1, cy = 1;
  const visited = new Set();
  visited.add(cy+","+cx);
  stack.push({x: cx, y: cy});

  while(stack.length > 0) {
    const current = stack[stack.length - 1];
    const neighbors = [];
    const directions = [
      {dx: 0, dy: -2, wall: {x: current.x, y: current.y - 1}},
      {dx: 0, dy: 2, wall: {x: current.x, y: current.y + 1}},
      {dx: -2, dy: 0, wall: {x: current.x - 1, y: current.y}},
      {dx: 2, dy: 0, wall: {x: current.x + 1, y: current.y}}
    ];

    for (const d of directions) {
      const nx = current.x + d.dx;
      const ny = current.y + d.dy;
      if(nx > 0 && ny > 0 && nx < GRID_SIZE && ny < GRID_SIZE) {
        if(!visited.has(ny+","+nx)) neighbors.push(d);
      }
    }

    if(neighbors.length > 0) {
      const chosen = neighbors[Math.floor(Math.random()*neighbors.length)];
      maze[chosen.wall.y][chosen.wall.x] = CELL_PATH;
      maze[current.y + chosen.dy][current.x + chosen.dx] = CELL_PATH;
      visited.add((current.y + chosen.dy)+","+(current.x + chosen.dx));
      stack.push({x: current.x + chosen.dx, y: current.y + chosen.dy});
    } else {
      stack.pop();
    }
  }

  maze[0][1] = CELL_PATH;

  // Define a sa√≠da em uma posi√ß√£o v√°lida no lado inferior que seja caminho (CELL_PATH)
  const exitCols = [];
  for(let col=1; col<GRID_SIZE-1; col++) {
    if(maze[GRID_SIZE-1][col] === CELL_PATH) exitCols.push(col);
  }
  const exitCol = exitCols[Math.floor(Math.random()*exitCols.length)];
  maze[GRID_SIZE-1][exitCol] = CELL_PATH;
  exitPosition = {x: exitCol, y: GRID_SIZE-1};

  return maze;
}

function generateMazes(count) {
  const arr = [];
  for(let i=0; i<count; i++) {
    arr.push(generateMaze());
  }
  return arr;
}

function renderMaze(maze) {
  mazeContainer.innerHTML = "";
  mazeContainer.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 20px)`;
  mazeContainer.style.gridTemplateRows = `repeat(${GRID_SIZE}, 20px)`;
  for (let y=0; y<GRID_SIZE; y++) {
    for(let x=0; x<GRID_SIZE; x++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      if(maze[y][x] === CELL_WALL) {
        cell.classList.add('wall');
      } else {
        cell.classList.add('path');
      }
      cell.setAttribute('data-x', x);
      cell.setAttribute('data-y', y);
      if(x === playerPosition.x && y === playerPosition.y) {
        cell.classList.add('player');
        cell.textContent = 'üê≠';
      } else if(x === exitPosition.x && y === exitPosition.y) {
        cell.innerHTML = 'üßÄ';
      }
      mazeContainer.appendChild(cell);
    }
  }
}

function placePlayer(pos) {
  if(gameCompleted) return false;
  document.querySelectorAll('.player').forEach(el => { el.textContent = ""; el.classList.remove('player'); });
  const newCell = mazeContainer.querySelector(`[data-x='${pos.x}'][data-y='${pos.y}']`);
  if(newCell && !newCell.classList.contains('wall')) {
    newCell.classList.add('player');
    newCell.textContent = 'üê≠';
    playerPosition = {x: pos.x, y: pos.y};
    return true;
  }
  // Permite entrar na c√©lula de sa√≠da mesmo que n√£o seja caminho (por seguran√ßa)
  if(newCell && newCell.getAttribute('data-x') == exitPosition.x && newCell.getAttribute('data-y') == exitPosition.y) {
    playerPosition = {x: pos.x, y: pos.y};
    return true;
  }
  return false;
}

function checkWin() {
  return playerPosition.x === exitPosition.x && playerPosition.y === exitPosition.y;
}

function showMessage(text) {
  message.textContent = text;
}

function movePlayer(direction) {
  if(gameCompleted) return;
  let newX = playerPosition.x;
  let newY = playerPosition.y;

  if(direction === 'up') newY--;
  else if(direction === 'down') newY++;
  else if(direction === 'left') newX--;
  else if(direction === 'right') newX++;

  if(placePlayer({x: newX, y: newY})) {
    if(checkWin()) {
      gameCompleted = true;
      showMessage("üéâ Voc√™ venceu! Pr√≥ximo labirinto em 3 segundos...");
      if (solvedTimeout) clearTimeout(solvedTimeout);
      solvedTimeout = setTimeout(() => {
        gameCompleted = false;
        currentMazeIndex = (currentMazeIndex + 1) % mazes.length;
        startMaze(currentMazeIndex);
      }, 3000);
    } else {
      showMessage("");
    }
  } else {
    playErrorSound();
    showMessage("üö´ N√£o √© por aqui! Tente outro caminho.");
  }
}

function handleKeyDown(e) {
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
    e.preventDefault();
  }
  switch(e.key) {
    case "ArrowUp": movePlayer('up'); break;
    case "ArrowDown": movePlayer('down'); break;
    case "ArrowLeft": movePlayer('left'); break;
    case "ArrowRight": movePlayer('right'); break;
  }
}

function setupTouchControls() {
  const area = mazeContainer;
  let startX, startY, endX, endY;
  area.addEventListener('touchstart', e => {
    const touch = e.touches[0];
    startX = touch.clientX;
    startY = touch.clientY;
  });
  area.addEventListener('touchend', e => {
    const touch = e.changedTouches[0];
    endX = touch.clientX;
    endY = touch.clientY;
    const dx = endX - startX;
    const dy = endY - startY;
    if(Math.abs(dx) > Math.abs(dy)) {
      if(dx > 30) movePlayer('right');
      else if(dx < -30) movePlayer('left');
    } else {
      if(dy > 30) movePlayer('down');
      else if(dy < -30) movePlayer('up');
    }
  });
  controls.up.addEventListener('click', () => movePlayer('up'));
  controls.down.addEventListener('click', () => movePlayer('down'));
  controls.left.addEventListener('click', () => movePlayer('left'));
  controls.right.addEventListener('click', () => movePlayer('right'));
}

function startMaze(index) {
  const maze = mazes[index];
  mazeContainer.innerHTML = "";
  mazeContainer.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 20px)`;
  mazeContainer.style.gridTemplateRows = `repeat(${GRID_SIZE}, 20px)`;
  playerPosition = {x: 1, y: 0};
  gameCompleted = false;

  // Encontrar poss√≠veis posi√ß√µes para sa√≠da (que sejam caminho)
  const exitCols = [];
  for(let col=1; col<GRID_SIZE-1; col++) {
    if(maze[GRID_SIZE-1][col] === CELL_PATH) exitCols.push(col);
  }
  const exitCol = exitCols[Math.floor(Math.random()*exitCols.length)];
  exitPosition = {x: exitCol, y: GRID_SIZE-1};

  renderMaze(maze);
  placePlayer(playerPosition);
  showMessage("");
}

window.onload = () => {
  mazes = generateMazes(100);
  currentMazeIndex = 0;
  startMaze(currentMazeIndex);
  window.addEventListener('keydown', handleKeyDown);
  setupTouchControls();
};
</script>
</body>
</html>
