<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo do Labirinto - MusiKids Fun</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Baloo+2&display=swap');
  body {
    margin: 0; padding: 0;
    font-family: 'Baloo 2', cursive, Arial, sans-serif;
    background: linear-gradient(135deg, #ffefd5, #ffc0cb);
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    min-height: 100vh;
  }
  #btn-menu {
    position: fixed;
    top: 15px;
    left: 15px;
    background: #a1d578;
    color: #214d0d;
    padding: 12px 22px;
    border-radius: 20px;
    font-weight: 900;
    border: none;
    cursor: pointer;
    box-shadow: 0 0 15px #a1d578cc;
    transition: background-color 0.3s ease;
    z-index: 10;
  }
  #btn-menu:hover {
    background-color: #68922b;
    color: white;
  }
  header {
    margin: 80px 0 15px;
    font-weight: 900;
    font-size: 2.8rem;
    color: #d63a6d;
  }
  #maze-container {
    display: grid;
    grid-template-columns: repeat(21, 30px);
    grid-template-rows: repeat(21, 30px);
    gap: 2px;
    background-color: #fff0f6;
    padding: 20px;
    border-radius: 20px;
    box-shadow: 0 0 30px #f3bbcfbb;
    touch-action: manipulation;
  }
  .cell {
    width: 30px;
    height: 30px;
    border-radius: 6px;
    box-sizing: border-box;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .wall {
    background-color: #4b2e83;
  }
  .path {
    background-color: #ffc0cb;
  }
  .player {
    font-size: 22px;
    user-select: none;
  }
  #message {
    margin-top: 25px;
    font-weight: 800;
    font-size: 1.3rem;
    color: #d63a6d;
    min-height: 24px;
    user-select: none;
  }
  #controls {
    margin-top: 20px;
    display: flex;
    gap: 15px;
    justify-content: center;
  }
  button.control-btn {
    background: #ffb6c1;
    border: none;
    padding: 15px 22px;
    border-radius: 14px;
    font-size: 1.3rem;
    font-weight: 700;
    color: #4b2e83;
    cursor: pointer;
    box-shadow: 0 0 15px #ffb6c1cc;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  button.control-btn:active {
    background-color: #d36487;
    color: white;
  }
  @media (max-width: 720px) {
    #maze-container {
      grid-template-columns: repeat(21, 22px);
      grid-template-rows: repeat(21, 22px);
      gap: 1.5px;
      padding: 15px;
    }
    .cell {
      width: 22px;
      height: 22px;
      border-radius: 4px;
      font-size: 18px;
    }
    button.control-btn {
      padding: 12px 18px;
      font-size: 1.0rem;
    }
  }
</style>
</head>
<body>
<button id="btn-menu" aria-label="Voltar ao menu">MENU DE JOGOS</button>
<header>Jogo do Labirinto - MusiKids Fun</header>
<div id="maze-container" aria-label="Labirinto"></div>
<div id="message" aria-live="assertive"></div>
<div id="controls" aria-label="Controles do jogo">
  <button class="control-btn" id="btn-up" aria-label="Mover para cima">‚¨ÜÔ∏è</button>
  <button class="control-btn" id="btn-left" aria-label="Mover para esquerda">‚¨ÖÔ∏è</button>
  <button class="control-btn" id="btn-down" aria-label="Mover para baixo">‚¨áÔ∏è</button>
  <button class="control-btn" id="btn-right" aria-label="Mover para direita">‚û°Ô∏è</button>
</div>

<script>
const btnMenu = document.getElementById('btn-menu');
btnMenu.onclick = () => location.href = '../index.html';

const mazeContainer = document.getElementById('maze-container');
const message = document.getElementById('message');
const controls = {
  up: document.getElementById('btn-up'),
  left: document.getElementById('btn-left'),
  down: document.getElementById('btn-down'),
  right: document.getElementById('btn-right')
};

const CELL_WALL = 1;
const CELL_PATH = 0;

const GRID_SIZE = 21;

let mazes = [];
let currentMazeIndex = 0;
let playerPosition = {x: 1, y: 0};
let solvedTimeout = null;

function generateMaze() {
  const maze = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(CELL_WALL));
  for(let y=1; y<GRID_SIZE; y+=2) {
    for(let x=1; x<GRID_SIZE; x+=2) {
      maze[y][x] = CELL_PATH;
    }
  }

  const stack = [];
  let cx = 1, cy = 1;
  const visited = new Set();
  visited.add(cy+","+cx);
  stack.push({x: cx, y: cy});

  while(stack.length > 0) {
    const current = stack[stack.length - 1];
    const neighbors = [];
    const directions = [
      {dx: 0, dy: -2, wall: {x: current.x, y: current.y - 1}},
      {dx: 0, dy: 2, wall: {x: current.x, y: current.y + 1}},
      {dx: -2, dy: 0, wall: {x: current.x - 1, y: current.y}},
      {dx: 2, dy: 0, wall: {x: current.x + 1, y: current.y}}
    ];

    for (const d of directions) {
      const nx = current.x + d.dx;
      const ny = current.y + d.dy;
      if(nx > 0 && ny > 0 && nx < GRID_SIZE && ny < GRID_SIZE) {
        if(!visited.has(ny+","+nx)) neighbors.push(d);
      }
    }

    if(neighbors.length > 0) {
      const chosen = neighbors[Math.floor(Math.random()*neighbors.length)];
      maze[chosen.wall.y][chosen.wall.x] = CELL_PATH;
      maze[current.y + chosen.dy][current.x + chosen.dx] = CELL_PATH;
      visited.add((current.y + chosen.dy)+","+(current.x + chosen.dx));
      stack.push({x: current.x + chosen.dx, y: current.y + chosen.dy});
    } else {
      stack.pop();
    }
  }

  maze[0][1] = CELL_PATH;
  maze[GRID_SIZE-1][GRID_SIZE-2] = CELL_PATH;

  return maze;
}

function generateMazes(count) {
  const arr = [];
  for(let i=0; i<count; i++) {
    arr.push(generateMaze());
  }
  return arr;
}

function renderMaze(maze) {
  mazeContainer.innerHTML = "";
  mazeContainer.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 30px)`;
  mazeContainer.style.gridTemplateRows = `repeat(${GRID_SIZE}, 30px)`;
  for (let y=0; y<GRID_SIZE; y++) {
    for(let x=0; x<GRID_SIZE; x++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      if(maze[y][x] === CELL_WALL) {
        cell.classList.add('wall');
      } else {
        cell.classList.add('path');
      }
      cell.setAttribute('data-x', x);
      cell.setAttribute('data-y', y);
      mazeContainer.appendChild(cell);
    }
  }
}

function placePlayer(pos) {
  document.querySelectorAll('.player').forEach(el => el.classList.remove('player'));
  const newCell = mazeContainer.querySelector(`[data-x='${pos.x}'][data-y='${pos.y}']`);
  if(newCell && !newCell.classList.contains('wall')) {
    newCell.classList.add('player');
    newCell.textContent = 'üê∂'; // Imagem emoji do cachorro
    playerPosition = {x: pos.x, y: pos.y};
    return true;
  }
  return false;
}

function checkWin() {
  return playerPosition.x === GRID_SIZE-2 && playerPosition.y === GRID_SIZE-1;
}

function showMessage(text) {
  message.textContent = text;
}

function movePlayer(direction) {
  let newX = playerPosition.x;
  let newY = playerPosition.y;

  if(direction === 'up') newY--;
  else if(direction === 'down') newY++;
  else if(direction === 'left') newX--;
  else if(direction === 'right') newX++;

  if(placePlayer({x: newX, y: newY})) {
    if(checkWin()) {
      showMessage("üéâ Voc√™ venceu! Pr√≥ximo labirinto em 3 segundos...");
      if (solvedTimeout) clearTimeout(solvedTimeout);
      solvedTimeout = setTimeout(() => {
        currentMazeIndex = (currentMazeIndex+1) % mazes.length;
        startMaze(currentMazeIndex);
      }, 3000);
    } else {
      showMessage("");
    }
  } else {
    showMessage("Movimento inv√°lido! Tente outro caminho.");
  }
}

function handleKeyDown(e) {
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
    e.preventDefault();  // Impede que a p√°gina role ao usar as setas
  }
  switch(e.key) {
    case "ArrowUp": movePlayer('up'); break;
    case "ArrowDown": movePlayer('down'); break;
    case "ArrowLeft": movePlayer('left'); break;
    case "ArrowRight": movePlayer('right'); break;
  }
}

function setupTouchControls() {
  const area = mazeContainer;
  let startX, startY, endX, endY;
  area.addEventListener('touchstart', e => {
    const touch = e.touches[0];
    startX = touch.clientX;
    startY = touch.clientY;
  });
  area.addEventListener('touchend', e => {
    const touch = e.changedTouches[0];
    endX = touch.clientX;
    endY = touch.clientY;
    const dx = endX - startX;
    const dy = endY - startY;
    if(Math.abs(dx) > Math.abs(dy)) {
      if(dx > 30) movePlayer('right');
      else if(dx < -30) movePlayer('left');
    } else {
      if(dy > 30) movePlayer('down');
      else if(dy < -30) movePlayer('up');
    }
  });
}

function startMaze(index) {
  const maze = mazes[index];
  renderMaze(maze);
  placePlayer({x: 1, y: 0}); // start position after entrance
  showMessage("");
}

window.onload = () => {
  mazes = generateMazes(100);
  currentMazeIndex = 0;
  startMaze(currentMazeIndex);
  window.addEventListener('keydown', handleKeyDown);
  setupTouchControls();
};
</script>
</body>
</html>
